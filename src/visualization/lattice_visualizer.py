"""
Interactive lattice visualization for 3WayCoT concept relationships.

This module provides tools to visualize the concept lattice generated by the
Triadic FCA component, showing relationships between concepts and their properties.
"""

import networkx as nx
import plotly.graph_objects as go
from typing import Dict, List, Any, Optional
import numpy as np

class LatticeVisualizer:
    """Visualize concept lattices with interactive features."""
    
    def __init__(self, concept_data: Dict[str, Any]):
        """Initialize with concept data from TriadicFCA.
        
        Args:
            concept_data: Dictionary containing concept lattice information
        """
        self.concept_data = concept_data
        self.graph = self._build_lattice_graph()
    
    def _build_lattice_graph(self) -> nx.DiGraph:
        """Build a directed graph representing the concept lattice."""
        G = nx.DiGraph()
        
        # Add nodes with concept information
        for concept_id, concept in self.concept_data.get('concepts', {}).items():
            G.add_node(concept_id, **concept)
            
        # Add edges representing subconcept-superconcept relationships
        for edge in self.concept_data.get('edges', []):
            G.add_edge(edge['source'], edge['target'])
            
        return G
    
    def visualize(self, output_file: Optional[str] = None, show: bool = True):
        """Generate an interactive visualization of the concept lattice.
        
        Args:
            output_file: Path to save the visualization (HTML)
            show: Whether to display the visualization
            
        Returns:
            plotly Figure object
        """
        pos = nx.spring_layout(self.graph, k=1, iterations=100)
        
        edge_x = []
        edge_y = []
        for edge in self.graph.edges():
            x0, y0 = pos[edge[0]]
            x1, y1 = pos[edge[1]]
            edge_x.extend([x0, x1, None])
            edge_y.extend([y0, y1, None])

        edge_trace = go.Scatter(
            x=edge_x, y=edge_y,
            line=dict(width=0.5, color='#888'),
            hoverinfo='none',
            mode='lines')

        node_x = []
        node_y = []
        node_text = []
        for node in self.graph.nodes():
            x, y = pos[node]
            node_x.append(x)
            node_y.append(y)
            node_text.append(f"{node}<br>Objects: {len(self.graph.nodes[node].get('objects', []))}<br>"
                          f"Attributes: {len(self.graph.nodes[node].get('attributes', []))}")

        node_trace = go.Scatter(
            x=node_x, y=node_y,
            mode='markers+text',
            hoverinfo='text',
            textposition="top center",
            textfont=dict(size=10),
            marker=dict(
                showscale=True,
                colorscale='YlGnBu',
                size=20,
                color=[],
                line_width=2))

        node_trace.text = node_text
        
        # Color nodes by number of objects
        node_adjacencies = []
        for node in self.graph.nodes():
            node_adjacencies.append(len(self.graph.nodes[node].get('objects', [])))
        
        node_trace.marker.color = node_adjacencies
        node_trace.marker.colorscale = 'YlGnBu'
        node_trace.marker.showscale = True
        node_trace.marker.colorbar = dict(
            thickness=15,
            title='Object Count',
            xanchor='left',
            titleside='right'
        )

        fig = go.Figure(data=[edge_trace, node_trace],
                       layout=go.Layout(
                           title='3WayCoT Concept Lattice',
                           titlefont_size=16,
                           showlegend=False,
                           hovermode='closest',
                           margin=dict(b=20, l=5, r=5, t=40),
                           xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                           yaxis=dict(showgrid=False, zeroline=False, showticklabels=False))
                       )
        
        if output_file:
            fig.write_html(output_file)
        
        if show:
            fig.show()
            
        return fig
